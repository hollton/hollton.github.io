<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端开发一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="HOLLTON">
<meta property="og:url" content="http://hollton.github.io/index.html">
<meta property="og:site_name" content="HOLLTON">
<meta property="og:description" content="前端开发一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HOLLTON">
<meta name="twitter:description" content="前端开发一枚">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hollton.github.io/"/>





  <title> HOLLTON </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HOLLTON</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">懂点编程，懂点艺术，懂点美。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/03/14/JavaScript语言精粹/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/JavaScript语言精粹/" itemprop="url">
                  JavaScript语言精粹
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T12:12:23+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/JavaScript语言精粹/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/JavaScript语言精粹/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-精华"><a href="#第一章-精华" class="headerlink" title="第一章 精华"></a>第一章 精华</h1><h1 id="第二章-语法"><a href="#第二章-语法" class="headerlink" title="第二章 语法"></a>第二章 语法</h1><h2 id="铁路图"><a href="#铁路图" class="headerlink" title="铁路图"></a>铁路图</h2><p><ul><br>    <li>从左边开始，沿着轨道到右边界</li><br>    <li>圆框中是字面量，方框中是规则或描述</li><br>    <li>任何沿着轨道能走通的序列都是合法的，反之是非法的</li><br>    <li>末端只有一个竖条的铁路图，表示允许在任意一对符号中插入空白。而末端有两个竖条的则不允许。</li><br></ul></p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>指数表示法：字面量值等于e之前的数字与10的e之后数字的次方相乘，即 100 等于1e2.<br>NaN：数值，表示不能产生正常结果的运算结果，不等于任何值NaN!=NaN，通过isNaN(number)检测。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>for in 会枚举对象的所有属性名（或键名），通过hasOwnProperty()检测某属性是该对象的成员，还是来自原型链。</p>
<pre><code>for (myvar in obj){
    if(obj.hasOwnProperty(myvar)){
        ...
    }
}
</code></pre><p>break使程序退出循环或switch语句，如果指定标签则退出带有该标签的程序段（可用于退出嵌套循环，continue同）</p>
<pre><code>hollton : for(var i=0;i&lt;3;i++){
    for(var j=0;j&lt;3;j++){
        if(i===1&amp;&amp;j===1){
            break hollton;
        }else{
            console.log(&quot;i:&quot;+i+&quot;--j:&quot;+j);
        }
    }
}
</code></pre><p>如果没指定标签，break只退出内部循环，指定标签后，则退出标签指定的代码段，即整个循环。</p>
<h1 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对象通过引用传递，永远不会被复制。</p>
<pre><code>var x = {};
var y = x;
y.name = &apos;hah&apos;;
console.log(x.name);  //&apos;hah&apos;,因为x,y指向同一个对象的引用

var a = {},b = {};  //a,b引用一个不同的空对象
var a = b = {};  //a,b引用同一个的空对象
</code></pre><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个对象都连接到一个原型对象，并可从中继承属性。原型连接只在检索值的时候才被用到，获取某个对象的某属性值时，若该对象没此属性名，则js从原型对象中获取，若原型对象中也没有，再从原型链上获取，直到Object.prototype，仍不存在返回undefined。这个过程称为委托。</p>
<h1 id="第四章-函数"><a href="#第四章-函数" class="headerlink" title="第四章 函数"></a>第四章 函数</h1><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。函数接收两个附加的参数：this和arguments。this的取值取决于调用的模式。<br>JavaScript共有4种调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。</p>
<h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><p>当函数被保存为对象的属性时，称之为方法。当方法被调用时，this被绑定到该对象，通过this可获取到所属对象的上下文的方法称为公共方法。</p>
<h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><p>当函数不是对象的属性时，则作为函数调用，此时this被绑定到全局对象。导致内部函数不能通过this访问外部函数的属性及方法，但可通过在外部函数定义变量（如_this,that）并赋值为this，可使内部函数访问。</p>
<h2 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h2><p>若函数通过new调用，则会创建一个新对象，该新对象连接到该函数的prototype成员，同时this被绑定到该新对象上，即this指向该构造器实例。</p>
<h2 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h2><p>Fn.apply(obj,args)方法接收两个参数：</p>
<p><ol><br>    <li>obj是要绑定给this的值，即obj将代替Fn里的this对象</li><br>    <li>args是要传递给调用函数的参数数组，即args–&gt;arguments</li><br></ol><br>call同apply，只有参数列表不一样 ：Fn.call(obj,arg1,arg2,…)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/03/05/滴答，滴答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/滴答，滴答/" itemprop="url">
                  滴答，滴答
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T21:28:30+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/滴答，滴答/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/滴答，滴答/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>夜晚，正俯身在电脑前写着设计模式笔记，窗前忽然哗啦啦下起了小雨，莫名就吟出两句小学课本的内容：“下吧下吧，我要种瓜”，回想往事一切仿佛历历在目，却再也回不去。</p>
<blockquote>
<p>滴答，滴答<br>滴答，滴答，下雨啦，下雨啦。<br>麦苗说：“下吧，下吧，我要长大。”<br>桃树说：“下吧，下吧，我要开花。”<br>葵花子说：“下吧，下吧，我要发芽。”<br>小弟弟说：“下吧，下吧，我要种瓜。”<br>滴答，滴答，下雨啦，下雨啦。 </p>
</blockquote>
<p>　</p>
<blockquote>
<p>春天来了<br>春天对冰雪说了什么，<br>冰雪那么听话，都化了。<br>春天对小草说了什么，<br>小草那么听话，都绿了。<br>春天对花儿说了什么，<br>花儿那么听话，都开了。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/02/25/javascript设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/javascript设计模式/" itemprop="url">
                  JavaScript设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-25T16:05:40+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/25/javascript设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/25/javascript设计模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-富有表现力的javascript"><a href="#第一章-富有表现力的javascript" class="headerlink" title="第一章 富有表现力的javascript"></a>第一章 富有表现力的javascript</h1><h2 id="javascript的灵活性"><a href="#javascript的灵活性" class="headerlink" title="javascript的灵活性"></a>javascript的灵活性</h2><h3 id="过程式程序设计模式"><a href="#过程式程序设计模式" class="headerlink" title="过程式程序设计模式"></a>过程式程序设计模式</h3><pre><code>function startRun(){ ... };
function stopRun(){ ... };
</code></pre><p>特点：简单，但无法创建可以保存状态且具有仅对其内部状态进行操作的方法的对象。</p>
<h3 id="定义类，并把方法赋给该类的prototype属性"><a href="#定义类，并把方法赋给该类的prototype属性" class="headerlink" title="定义类，并把方法赋给该类的prototype属性"></a>定义类，并把方法赋给该类的prototype属性</h3><pre><code>var Run = function(){ ... };
Run.prototype = {
    start:function(){ ... },
    stop:function(){ ... }
};
/* usage */
var myRun = new Run();
myRun.start();
</code></pre><h3 id="自定义为类添加新方法"><a href="#自定义为类添加新方法" class="headerlink" title="自定义为类添加新方法"></a>自定义为类添加新方法</h3><pre><code>/* 给函数添加可自定义方法的方法 */
Function.prototype.customMethod = function(name,fn){
    this.prototype[name] = fn;
    //以下代码可使customMethod被链式调用
    //return this;
};
var Run = function(){ ... }
Run.customMethod(&apos;start&apos;,fuction(){
    ...
});
</code></pre><h2 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>布尔（Boolean），数值（Number不区分整数、浮点数），字符串（String），空（Null），未定义（Undefined）：按值传送</p>
<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>对象（Object：无序键值对；数组特殊对象：为有序集合）：按引用传送</p>
<h1 id="第二章-接口"><a href="#第二章-接口" class="headerlink" title="第二章 接口"></a>第二章 接口</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>接口提供了一种用以说明一个对象应该具有哪些方法的手段。我的理解是接口声明了一个方法所需的参数及返回的数据，并在类中去实现它。</p>
<h2 id="js模仿接口"><a href="#js模仿接口" class="headerlink" title="js模仿接口"></a>js模仿接口</h2><h3 id="注释描述"><a href="#注释描述" class="headerlink" title="注释描述"></a>注释描述</h3><p>在注释中使用interface,implements关键字。实现简单但仅限制于文档规范阶段，并没做实现检查，也不会抛出错误提示。</p>
<pre><code>/*
    interface Composite {
        function add(item);
    }
*/
var CompositeForm = function(id,method,action){  //implements Composite
};
//implement the Composite interface
CompositeForm.prototype.add = function(item){ ... }
</code></pre><h3 id="属性检查"><a href="#属性检查" class="headerlink" title="属性检查"></a>属性检查</h3><p>即通过检查属性判断是否实现此接口，没有则抛出错误，但并未对接口的真正实现做检查。</p>
<h3 id="鸭式辨型"><a href="#鸭式辨型" class="headerlink" title="鸭式辨型"></a>鸭式辨型</h3><p>不关注是否声明支持哪些方法，而只要具有这些接口的方法就行。双重遍历检测每个接口是否实现了某种方法.</p>
<h2 id="interface类"><a href="#interface类" class="headerlink" title="interface类"></a>interface类</h2><p>接口在运用设计模式实现复杂系统时能体现其价值，可降低对象间的耦合度，但对于小型项目，好处并不明显且徒增复杂度。</p>
<h1 id="第三章-封装和信息隐藏"><a href="#第三章-封装和信息隐藏" class="headerlink" title="第三章 封装和信息隐藏"></a>第三章 封装和信息隐藏</h1><h2 id="封装是面向对象设计的基石"><a href="#封装是面向对象设计的基石" class="headerlink" title="封装是面向对象设计的基石"></a>封装是面向对象设计的基石</h2><p>将方法或属性声明为私用，可以让对象的实现细节对其他对象保密以降低对象间耦合度，且可以保持数据的完整性并对其修改方式加以约束。js中可使用闭包创建只允许从对象内部访问的属性和方法，以达到封装数据的效果。</p>
<h2 id="创建对象的基本模式"><a href="#创建对象的基本模式" class="headerlink" title="创建对象的基本模式"></a>创建对象的基本模式</h2><h3 id="门户大开型"><a href="#门户大开型" class="headerlink" title="门户大开型"></a>门户大开型</h3><p>传统方式，用函数做其构造器，属性和方法公开，用this关键字创建属性。</p>
<pre><code>var book = function(title){
    this.setTitle(title);
};
book.prototype = {
    getTitle:function(){
        return this.title;
    },
    setTitle:function(title){
        this.title = title;
    },
    display:function(){ ... }
};
</code></pre><h3 id="命名规范（-）"><a href="#命名规范（-）" class="headerlink" title="命名规范（_）"></a>命名规范（_）</h3><p>属性和方法前添加下划线（_）以示其私有性。</p>
<h3 id="作用域、嵌套函数、闭包"><a href="#作用域、嵌套函数、闭包" class="headerlink" title="作用域、嵌套函数、闭包"></a>作用域、嵌套函数、闭包</h3><p>闭包函数能够访问另一个函数的内部变量，函数作用域内return一个嵌套函数即构成闭包。<br>之所以会产生闭包是因为js的作用域是词法性的，即函数运行在定义它们的作用域中，而不是调用它们的作用域。</p>
<pre><code>var book = function(newTitle){
    //私有属性
    var title;
    //特权方法（privileged method，公用却能访问私有属性）
    this.getTitle = function(){
        return title;
    };
    this.setTitle = function(newTitle){
        title = newTitle;
    };
    //构造函数代码
    this.setTitle(newTitle);
};
//公用方法
book.prototype.display = function(){ ... };
</code></pre><p>前两种方式的方法都创建在原型对象中，无论生成多少对象实例，方法只在内存中存一份。而采用闭包则每生成一个对象实例都为每一个私有方法和特权方法生成新副本，更耗内存。</p>
<h1 id="第四章-继承"><a href="#第四章-继承" class="headerlink" title="第四章 继承"></a>第四章 继承</h1><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><h3 id="简单类声明"><a href="#简单类声明" class="headerlink" title="简单类声明"></a>简单类声明</h3><p>函数声明类，new关键字创建实例。创建构造函数，其名称就是类名，首字母大写，实例属性使用this关键字，方法添加到其prototype对象中。</p>
<pre><code>/* Class Person */
function Person (name){
    this.name = name;
};
Person.prototype.getName = function(){
    return this.name;
};
</code></pre><p>关键字new调用构造函数创建该类实例，即可访问实例属性及方法。</p>
<pre><code>var hollton = new Person(&apos;hollton&apos;);
</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ol><br>    <li>创建一个构造函数，在函数中调用超类的构造函数。<ul><li>使用new时，系统会创建一个空对象，然后调用构造函数，在此过程中这个空对象处于作用域链最前端。而子类调用超类的构造函数时，必须手动完成这项工作。“Person.call(this,name)”使空对象（用this代表），name作参数传入。</li></ul></li><br>    <li>设置原型链，指向实例超类<ul><li>访问对象的某个成员时，如果在当前对象中查找不到，javascript会沿着对象的原型链向上逐一访问其原型对象查找，因此将子类的prototype指向超类的一个实例，即可使子类继承超类。</li></ul></li><br>    <li>重新设置constructor属性为本构造函数<ul><li>定义构造函数时，默认的prototype对象是Object类型的实例，其constructor属性会被自动设置为该构造函数。但手动将其prototype设置为另一个对象时，其constructor属也变成新对象的constructor值，因此需要重新设置为本构造函数。</li></ul></li><br></ol>

<pre><code>/* Class Programmer */
function Programmer(name,programs){
    Person.call(this,name);//当前作用域调用超类的构造函数
    this.programs = programs;//添加新属性
};
Programmer.prototype = new Person();//设置原型链
Programmer.prototype.constructor = Programmer;//重新设置constructor属性
Programmer.prototype.getPrograms = function(){//添加新方法
    return this.programs;
};
</code></pre><p>创建子类实例则不变</p>
<pre><code>var holltonliu = new Programmer(&apos;hollton&apos;,[&apos;javascript_code&apos;]);
</code></pre><h3 id="自定义extend函数"><a href="#自定义extend函数" class="headerlink" title="自定义extend函数"></a>自定义extend函数</h3><p>仿照extend关键字自定义函数实现基于给定类结构创建新类。其中添加一个空函数fn，其prototype指向超类的prototype并创建对象实例插入到子类的原型链中。这样是为了避免创建超类的实例（直接使用超类可能：比较大；有副作用；执行大量计算任务）。</p>
<pre><code>/* Extend function */
function extend(subClass, superClass) {
    var fn = function(){};
    fn.prototype = superClass.prototype;
    subClass.prototype = new fn();
    subClass.prototype.constructor = subClass;
}
</code></pre><p>使用extend函数对上述例子改造：</p>
<pre><code>function Programmer(name,programs){
    Person.call(this,name);  //存在耦合
    this.programs = programs;
};
extend(Programmer,Person);
Programmer.prototype.getPrograms = function(){
    return this.programs;
};
</code></pre><p>存在缺陷：超类（Person）被固化在子类（Programmer）的声明中，为子类添加superPrototype属性解决↓</p>
<pre><code>/* ---Improved Extend function--- */
function extend(subClass, superClass) {
    var fn = function(){};
    fn.prototype = superClass.prototype;
    subClass.prototype = new fn();
    subClass.prototype.constructor = subClass;

    subClass.superPrototype = superClass.prototype;
    //超类为Object类或也由他处继承而来时，有可能导致constructor指向不正确，不正确时修复。
    //子类会通过constructor指向调用超类构造函数，因此这个判断修复很重要！
    if(superClass.prototype.constructor == Object.prototype.constructor){
        superClass.prototype.constructor = superClass;
    }
}
function Programmer(name,programs){
    Person.superPrototype.constructor.call(this,name);
    this.programs = programs;
};
extend(Programmer,Person);
</code></pre><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>创建一个对象，由于原型链的查找机制，新对象只需重用此对象即可实现继承。</p>
<pre><code>/* Person Prototype Object */
var Person = {
    name:&apos;default&apos;,
    getName:function(){
        return this.name;
    }
};
//customClone创建并返回新空对象，其原型对象指向父级对象
//当新对象找不到某个属性或方法时会在原型链上查找
function customClone(superObject) {
    function fn() {};
    fn.prototype = superObject;
    return new fn;  //相当于new fn()
}
/* Programmer Prototype Object */
var Programmer = customClone(Person);
Programmer.programs = [];
Programmer.getPrograms = function(){
    return this.programs;
};
var hollton = customClone(Programmer);
hollton.name = &apos;hollton&apos;;
hollton.programs = [&apos;javascript_code&apos;];
hollton.getName();
hollton.getPrograms();
</code></pre><h3 id="继承成员的读写不对等性"><a href="#继承成员的读写不对等性" class="headerlink" title="继承成员的读写不对等性"></a>继承成员的读写不对等性</h3><p>在类式继承中，每个实例都有一份自己的副本，而通过原型继承，实例只是以父对象为原型对象的空对象，没为其指定属性时，读取是返指原型链上的同名属性，写入则为其定义一个新属性。这里特别要注意的是，对于引用传递的数据类型如数组，对新对象第一次不赋值写入而做操作如push时会修改其原型链上的数据。</p>
<pre><code>var hd = customClone(Programmer);
console.log(Programmer.programs);  //[]
//不应这么做
hd.programs.push(&apos;javascript_code&apos;);
console.log(Programmer.programs);  //[&apos;javascript_code&apos;]
//应该
hd.programs = [];  //为hd对象添加新属性
hd.programs.push(&apos;javascript_code&apos;);
console.log(Programmer.programs);  //[]
</code></pre><h3 id="工厂方式实现"><a href="#工厂方式实现" class="headerlink" title="工厂方式实现"></a>工厂方式实现</h3><p>如果需求继承一个对象而只修改其子对象的的一个属性保留其他，应用上种方法你必须知道对象的全部属性及其默认值并做覆盖操作，显然不合适。</p>
<pre><code>var CompoundObject = {};
CompoundObject.name = &apos;haha&apos;;
CompoundObject.createChildObject = function(){
    return {
        num:10,
        bool:true
    }
};
CompoundObject.childObject = CompoundObject.createChildObject();

var compoundObjectClone = customClone(CompoundObject);
compoundObjectClone.childObject = CompoundObject.createChildObject();
compoundObjectClone.childObject.num = 5;  //修改不会影响CompoundObject
</code></pre><h2 id="参元类"><a href="#参元类" class="headerlink" title="参元类"></a>参元类</h2><p>包含通用方法的类，用来扩充其他类，称这个通用类为参元类(mixin class)。它们通常不会被实例或直接调用，只是向其他类提供自己的方法。</p>
<pre><code>/* Mixin class */
var Mixin = function(){};
Mixin.prototype = {
    fnName:function(){ ... }
}
</code></pre><p>这个方法在不同类中用到时，没必要都去继承它，我们可以自定义个customArgument函数将它添加到需要用到它的类中。</p>
<pre><code>function customArgument(receiveClass, giveClass){
    for(methodName in giveClass.prototype){
        if(!receiveClass.prototype[methodName]){
            receiveClass.prototype[methodName] = giveClass.prototype[methodName];
        }
    }
}

customArgument(Programmer,Mixin);
var hd. = new Programmer(&apos;hollton&apos;,[&apos;javascript_code&apos;]);
hd.fnName();  //使用参元类方法
</code></pre><h1 id="第五章-单体模式"><a href="#第五章-单体模式" class="headerlink" title="第五章 单体模式"></a>第五章 单体模式</h1><p>单体是一个用来划分命名空间并将一批相关方法和属性组织在一起的对象，如果可被实例化，则只能被实例化一次。</p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><pre><code>/* 简单单体（对象字面量） */
var Singleton = {
    attribute:10,
    method:function(){}
};
</code></pre><h2 id="拥有私有成员的单体"><a href="#拥有私有成员的单体" class="headerlink" title="拥有私有成员的单体"></a>拥有私有成员的单体</h2><p>创建类的私有成员的做法缺点在于较耗内存，因为每个实例都具有方法的一份新副本。由于单体对象只会被实例化一次，因此为其定义私用方法是不必考虑内存方面的问题。</p>
<h3 id="下划线标识"><a href="#下划线标识" class="headerlink" title="下划线标识"></a>下划线标识</h3><h3 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h3><pre><code>MyNamespace.Singleton = (function(){
    //私有
    var privateAtti = false;
    function privateMethod = function(){};
    //公有
    return {
        publicAtti = true;
        publicMethod = function(){};
    };
})();
</code></pre><p>这种单体模式又称模块模式，它可以把一批相关的方法和属性组织为模块并起到划分命名空间的作用。</p>
<h2 id="惰性实例化"><a href="#惰性实例化" class="headerlink" title="惰性实例化"></a>惰性实例化</h2><p>将单体对象实例化推迟到需要使用的时候，称为惰性加载。特别之处是需借助静态方法调用MyNamespace.Singleton.publicMethod -&gt; MyNamespace.Singleton.getInstace().publicMethod。getInstace方法会检查并返回该单体的实例化对象。</p>
<pre><code>MyNamespace.Singleton = (function(){
    function constructor(){
        var privateAtti = false;
        function privateMethod = function(){};
        return {
            publicAtti = true;
            publicMethod = function(){};
        };
    }
    var uniqueInstance;
    return {
        getInstance:function(){
            if(!uniqueInstance){
                uniqueInstance = constructor();
            }
            return uniqueInstance;
        }
    }
})();
</code></pre><h1 id="第六章-方法的链式调用"><a href="#第六章-方法的链式调用" class="headerlink" title="第六章 方法的链式调用"></a>第六章 方法的链式调用</h1><p>类的每个方法都return this实现支持方法链式调用的类。</p>
<h1 id="第七章-工厂模式"><a href="#第七章-工厂模式" class="headerlink" title="第七章 工厂模式"></a>第七章 工厂模式</h1><p>简单工厂使用一个类（通常是一个单体）来生成实例，标准工厂使用子类来决定一个成员变量应该是哪个具体类的实例。</p>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂就像一个单例，它有一个或多个方法来创建或者返回对象。</p>
<pre><code>/* BicycleShop Class */
var BicycleShop = function(){};
BicycleShop.prototype = {
    sellBicycle:function(model){
        var bicycle;
        switch (model){
            case &apos;speedster&apos;:
                bicycle = new Speedster();
                break;
            case &apos;lowrider&apos;:
                bicycle = new Lowrider();
                break;
            default:
                bicycle = new Common();
        }
        return bicycle;
    }
}

/* Speedster Class */
var Speedster = function(){};
Speedster.prototype = {
    assemble:function(){},
    ride:function(){}
}
var newBicycleShop = new BicycleShop();
var newBike = newBicycleShop.sellBicycle(&apos;speedster&apos;);
</code></pre><p>当添加一种车型时，不得不BicycleShop代码，更好的方式是在子类中创建车型。</p>
<h2 id="标准工厂"><a href="#标准工厂" class="headerlink" title="标准工厂"></a>标准工厂</h2><p>工厂是一个将其成员对象的实例化推迟到子类中进行的类。把BicycleShop设计成抽象类，只实现通用方法，让子类各自实现个性如createBicycle方法。</p>
<pre><code>/* BicycleShop Class (abstract) */
var BicycleShop = function(){};
BicycleShop.prototype = {
    sellBicycle:function(model){
        var bicycle = this.createBicycle(model);
        return bicycle;
    },
    createBicycle:function(model){
        throw new Error(&apos;createBicycle须由子类实现&apos;);
    };
}

/* SubBicycleShop Class */
var SubBicycleShop = function(){};
SubBicycleShop.prototype = new BicycleShop();
SubBicycleShop.prototype.createBicycle = function(model){
        var bicycle;
        switch (model){
            case &apos;speedster&apos;:
                bicycle = new SubSpeedster();
                break;
            case &apos;lowrider&apos;:
                bicycle = new SubLowrider();
                break;
            default:
                bicycle = new SubCommon();
        }
        return bicycle;
    };
}
</code></pre><h2 id="memoizing技术"><a href="#memoizing技术" class="headerlink" title="memoizing技术"></a>memoizing技术</h2><p>memoizing把函数的每次执行结果都存入键值对(数组)，下次直接在键值对中查找值，有则返回该值，没有则执行函数体并再次缓存。</p>
<h1 id="第八章-桥接模式"><a href="#第八章-桥接模式" class="headerlink" title="第八章 桥接模式"></a>第八章 桥接模式</h1><p>桥接模式最常见和实际的应用场合之一是事件监听器回调函数。</p>
<h2 id="示例：事件监听器"><a href="#示例：事件监听器" class="headerlink" title="示例：事件监听器"></a>示例：事件监听器</h2><pre><code>addEvent(ele,&apos;click&apos;,getBeerById);
function getBeerById (e){
    asyncRequest(&apos;GET&apos;,&apos;/getBeer?id=&apos;+this.id,function(resp){
        console.log(resp);
    });
}
</code></pre><p>作为一个API函数，不应与特定实现混在一起。用桥接模式修改，把抽象隔离开来。</p>
<pre><code>function getBeerById (id,callBack){
    asyncRequest(&apos;GET&apos;,&apos;/getBeer?id=&apos;+id,function(resp){
        callBack(resp);
    });
}
addEvent(ele,&apos;click&apos;,getBeerByIdBridge);
function getBeerByIdBridge (e){
    getBeerById(this.id,function(beer){
        console.log(beer);
    });
}
</code></pre><p>如果一个桥接函数被用于连接两个函数，而其中某个函数根本不会在桥接函数外被调用，那么这个桥接函数就是不必要的。</p>
<h1 id="第九章-组合模式"><a href="#第九章-组合模式" class="headerlink" title="第九章 组合模式"></a>第九章 组合模式</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2016/12/19/vue-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/19/vue-cli/" itemprop="url">
                  vue-cli构建工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-19T10:41:40+08:00">
                2016-12-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/19/vue-cli/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/19/vue-cli/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>安装node.js、git</p>
<h2 id="shell-命令"><a href="#shell-命令" class="headerlink" title="shell 命令"></a>shell 命令</h2><p><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code>(使用taobao NPM镜像，可用cnpm代替npm)</p>
<p><code>cd E:/WWW</code></p>
<p><code>npm install -g vue-cli</code>(全局安装vue-cli)</p>
<p><code>vue init webpack#1.0 vue-project</code>(可选安装1.0)</p>
<p><code>cd vue-project</code></p>
<p><code>npm install</code>(安装依赖)</p>
<p><code>npm run dev</code>(启动)</p>
<h2 id="官方模版"><a href="#官方模版" class="headerlink" title="官方模版"></a>官方模版</h2><p><code>vue init template-name project-name</code></p>
<p><a href="https://github.com/vuejs-templates/browserify" target="_blank" rel="external">browserify</a>–全功能的Browserify + vueify，包括热加载，静态检测，单元测试</p>
<p><a href="https://github.com/vuejs-templates/browserify-simple" target="_blank" rel="external">browserify-simple</a>–一个简易的Browserify + vueify，以便于快速开始</p>
<p><a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">webpack</a>–全功能的Webpack + vueify，包括热加载，静态检测，单元测试</p>
<p><a href="https://github.com/vuejs-templates/webpack-simple" target="_blank" rel="external">webpack-simple</a>–一个简易的Webpack + vueify，以便于快速开始</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2015/05/11/github如何更新自己Fork的代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/11/github如何更新自己Fork的代码/" itemprop="url">
                  github如何更新自己Fork的代码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-11T15:27:36+08:00">
                2015-05-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/05/11/github如何更新自己Fork的代码/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/11/github如何更新自己Fork的代码/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>github有fork功能，可以将别人的项目复制到自己账号下，但其有一个缺点就是当别人的源项目更新后，你fork的分支并不会一起更新，需要我们手动去更新。<br>下面就以我的帐号：hollton，以及fork的项目：<a href="https://github.com/fat/zoom.js.git" target="_blank" rel="external">zoom.js</a>为例为大家讲述如何同步更新自己的代码。</p>
<h5 id="1、clone自己账号里fork的分支"><a href="#1、clone自己账号里fork的分支" class="headerlink" title="1、clone自己账号里fork的分支"></a>1、clone自己账号里fork的分支</h5><pre><code>$ git clone https://github.com/hollton/zoom.js.git
$ cd zoom.js
</code></pre><h5 id="2、增加远程原始分支"><a href="#2、增加远程原始分支" class="headerlink" title="2、增加远程原始分支"></a>2、增加远程原始分支</h5><pre><code>$ git remote add fat.zoom.js https://github.com/fat/zoom.js.git
</code></pre><p>其中fat.zoom.js可随意写</p>
<h6 id="接着可以查看远程分支列表"><a href="#接着可以查看远程分支列表" class="headerlink" title="接着可以查看远程分支列表"></a>接着可以查看远程分支列表</h6><pre><code>$ git remote -v
</code></pre><p><img src="/img/fork.png" alt=""></p>
<h5 id="3、fetch源分支的新版本到本地仓库"><a href="#3、fetch源分支的新版本到本地仓库" class="headerlink" title="3、fetch源分支的新版本到本地仓库"></a>3、fetch源分支的新版本到本地仓库</h5><pre><code>$ git fetch fat.zoom.js
</code></pre><h5 id="4、合并源新版本与自己版本代码"><a href="#4、合并源新版本与自己版本代码" class="headerlink" title="4、合并源新版本与自己版本代码"></a>4、合并源新版本与自己版本代码</h5><pre><code>git merge fat.zoom.js/master
</code></pre><h5 id="5、把合并后的代码push到自己的github上"><a href="#5、把合并后的代码push到自己的github上" class="headerlink" title="5、把合并后的代码push到自己的github上"></a>5、把合并后的代码push到自己的github上</h5><pre><code>$ git push origin master
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2015/04/23/Unveil-js图片延时加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/23/Unveil-js图片延时加载/" itemprop="url">
                  Unveil.js图片延时加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-23T11:37:34+08:00">
                2015-04-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/04/23/Unveil-js图片延时加载/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/23/Unveil-js图片延时加载/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Unveil-js是一个jQuery图片延时加载插件且极轻量。支持IE7。"><a href="#Unveil-js是一个jQuery图片延时加载插件且极轻量。支持IE7。" class="headerlink" title="Unveil.js是一个jQuery图片延时加载插件且极轻量。支持IE7。"></a>Unveil.js是一个jQuery图片延时加载插件且极轻量。支持IE7。</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>&lt;img src=&quot;bg.png&quot; data-src=&quot;original-img.jpg&quot; data-src-retina=&quot;img-retina.jpg&quot; /&gt;

&lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;jquery.unveil.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(document).ready(function() {
        $(&quot;img&quot;).unveil();
    });
&lt;/script&gt;
</code></pre><p>首先src属性里需要一个占位图片。<br>data-src为要加载的原始图片，当页面滑动到其可视窗口时再显示。<br>如果想支持视网膜设备加载高分辨率图片，则需要使用data-src-retina，但这不是必需的。</p>
<h3 id="如果担心用户没有启用javascript，则使用下面降级。"><a href="#如果担心用户没有启用javascript，则使用下面降级。" class="headerlink" title="如果担心用户没有启用javascript，则使用下面降级。"></a>如果担心用户没有启用javascript，则使用下面降级。</h3><pre><code>&lt;noscript&gt;
    &lt;img src=&quot;original-img.jpg.jpg&quot; /&gt;
&lt;/noscript&gt;
</code></pre><h3 id="使用参数可使图片距离视口100px就开始加载。"><a href="#使用参数可使图片距离视口100px就开始加载。" class="headerlink" title="使用参数可使图片距离视口100px就开始加载。"></a>使用参数可使图片距离视口100px就开始加载。</h3><pre><code>$(&quot;img&quot;).unveil(100);
</code></pre><h3 id="更好的是它支持回调函数，如："><a href="#更好的是它支持回调函数，如：" class="headerlink" title="更好的是它支持回调函数，如："></a>更好的是它支持回调函数，如：</h3><pre><code>$(&quot;img&quot;).unveil(100,callback);
</code></pre><h3 id="图片淡出加载例子"><a href="#图片淡出加载例子" class="headerlink" title="图片淡出加载例子"></a>图片淡出加载例子</h3><pre><code>img {
    opacity: 0;
    transition: opacity .3s ease-in;
}

$(&quot;img&quot;).unveil(100, function() {
    $(this).load(function() {
    this.style.opacity = 1;
    });
});
</code></pre><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><pre><code>$(&quot;img#tri&quot;).trigger(&quot;unveil&quot;);
</code></pre><p>手动触发加载特定图片而不使用此方法。</p>
<h3 id="Layzr-js"><a href="#Layzr-js" class="headerlink" title="Layzr.js"></a>Layzr.js</h3><p>顺便再说一个刚发布的轻巧、不依赖jQuery的延时加载，同样支持视网膜设备。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>&lt;img src=&quot;bg.png&quot; data-src=&quot;original-img.jpg&quot; data-src-retina=&quot;img-retina.jpg&quot; /&gt;
&lt;script src=&quot;layzr.min..js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var layzr = new Layzr({
        selector: &apos;[data-layzr]&apos;, 
        attr: &apos;data-layzr&apos;, 
        retinaAttr: &apos;data-layzr-retina&apos;, 
        bgAttr: &apos;data-layzr-bg&apos;, 
        threshold: 0, 
        callback: null 
    });
&lt;/script&gt;
</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>支持IE10+。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/css/images/avatar.png"
               alt="hollton" />
          <p class="site-author-name" itemprop="name">hollton</p>
           
              <p class="site-description motion-element" itemprop="description">前端开发一枚</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hollton</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hollton"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
