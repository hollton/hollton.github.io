<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前端开发一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="HOLLTON">
<meta property="og:url" content="http://hollton.github.io/index.html">
<meta property="og:site_name" content="HOLLTON">
<meta property="og:description" content="前端开发一枚">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HOLLTON">
<meta name="twitter:description" content="前端开发一枚">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hollton.github.io/"/>





  <title> HOLLTON </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HOLLTON</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">懂点编程，懂点艺术，懂点美。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/05/14/个人工作项目总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/14/个人工作项目总结/" itemprop="url">
                  个人工作项目总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-14T17:41:07+08:00">
                2017-05-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/14/个人工作项目总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/14/个人工作项目总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="备课系统"><a href="#备课系统" class="headerlink" title="备课系统"></a>备课系统</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h2 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h2><h2 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h2><h1 id="北京高精尖"><a href="#北京高精尖" class="headerlink" title="北京高精尖"></a>北京高精尖</h1><h2 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h2><h2 id="工作内容-1"><a href="#工作内容-1" class="headerlink" title="工作内容"></a>工作内容</h2><h2 id="工作总结-1"><a href="#工作总结-1" class="headerlink" title="工作总结"></a>工作总结</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/05/14/UML学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/14/UML学习笔记/" itemprop="url">
                  UML学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-14T16:28:37+08:00">
                2017-05-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/14/UML学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/14/UML学习笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>UML（Unified Modeling Language）:统一建模语言。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>结构型（Structrue Diagram）：</p>
<ul><br>    <li>类图(Class)</li><br>    <li>对象图(Object)</li><br>    <li>构件/组件图(Component)</li><br>    <li>部署图(Deployment)</li><br>    <li>包图(Package)</li><br></ul><br>行为型（Behavior Diagram）：<br><ul><br>    <li>活动图(Activity)</li><br>    <li>状态机图(State Machine)</li><br>    <li>顺序图(Sequence)</li><br>    <li>通信图(Communication)</li><br>    <li>用例图(use Case)</li><br>    <li>时序图(Timing)</li><br></ul>

<h1 id="类图（业务模型分析）"><a href="#类图（业务模型分析）" class="headerlink" title="类图（业务模型分析）"></a>类图（业务模型分析）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个类用矩形方框表示，最上面是类的名字，中间是属性，最下面是操作。<br><img src="/img/class_diagram.png" alt=""><br>上图 +属性1:int ,+表示为public类型，int表数据类型。操作同。</p>
<h2 id="设计类步骤"><a href="#设计类步骤" class="headerlink" title="设计类步骤"></a>设计类步骤</h2><p><ul><br>    <li>识别出类</li><br>    <li>识别出类的主要属性</li><br>    <li>描绘出类之间的关系</li><br>    <li>对各类进行分析、抽象、整理</li><br></ul></p>
<h2 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h2><h3 id="关联关系（“直线”关系）"><a href="#关联关系（“直线”关系）" class="headerlink" title="关联关系（“直线”关系）"></a>关联关系（“直线”关系）</h3><p>暂不确定两个类的关系时，可先用直线连接标明有某种关系（类用矩形框画出，下面用[]示意）<br>[A]1—1[B]：A、B类之间为一对一关系；<br>[A]1—*[B]：一对多关系，*表示0到多个；<br>[A]1—x..y[B]：一对（x到y）关系；<br>[A]—&gt;[B]：由类A可找到类B，可记为“导航”关系。</p>
<h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><p>可用下类图表示一个部门有多个员工，父元素用菱形标记。<br><img src="/img/class_diagram_include.png" alt=""><br>聚合（弱包含）：空心菱形◇，子元素可以有多个父元素，当父元素不存在时，子元素仍可继续存在；<br>组合（强包含）：实心菱形◆，子元素只能有一个父元素，当父元素不存在时，子元素也不再存在。</p>
<h3 id="泛化关系（继承关系）"><a href="#泛化关系（继承关系）" class="headerlink" title="泛化关系（继承关系）"></a>泛化关系（继承关系）</h3><p>[学生]—▷[人]：用三角形表示，由继承者指向被继承者，即类学生继承了类人，正式称谓应为类学生泛化为类人（即有学生类可提炼抽象出人）。</p>
<h3 id="依赖关系（虚线-箭头）"><a href="#依赖关系（虚线-箭头）" class="headerlink" title="依赖关系（虚线+箭头）"></a>依赖关系（虚线+箭头）</h3><p>[酒鬼]——&gt;[酒]：依赖者用虚线及箭头指向依赖对象。</p>
<h3 id="递归关系（自包含关系）"><a href="#递归关系（自包含关系）" class="headerlink" title="递归关系（自包含关系）"></a>递归关系（自包含关系）</h3><p>如在表示文件夹与文件的关系时，可用文件夹类包含自己表示文件夹也可包含文件夹<br>这种递归结构展开时就为树形结构，因此树形结构可用自包含、自关联来表示</p>
<h3 id="三角关系"><a href="#三角关系" class="headerlink" title="三角关系"></a>三角关系</h3><p>公司与雇员之间还有一个劳动合同类的关联类，对这两个类的关系近一步约束<br><img src="/img/class_diagram_triangle.png" alt=""></p>
<h1 id="活动图（流程分析）"><a href="#活动图（流程分析）" class="headerlink" title="活动图（流程分析）"></a>活动图（流程分析）</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/05/12/Vue实践总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/12/Vue实践总结/" itemprop="url">
                  Vue实践总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T19:53:27+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/12/Vue实践总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/12/Vue实践总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS中使用filters"><a href="#JS中使用filters" class="headerlink" title="JS中使用filters"></a>JS中使用filters</h2><pre><code>参考：https://github.com/vuejs/Discussion/issues/405
Vue.filter(&apos;indexToLetterFilter&apos;, index =&gt; {
    return String.fromCharCode(65+index);
});
this.$options.filters.indexToLetterFilter(index);

&lt;!-- html中传参+串联 --&gt;
{{index | indexToLetterFilter('arg1', arg2) | anotherFilter}}
</code></pre><h2 id="data、computed、props优先级"><a href="#data、computed、props优先级" class="headerlink" title="data、computed、props优先级"></a>data、computed、props优先级</h2><p>data &gt; computed &gt; props</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/03/14/JavaScript语言精粹/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/JavaScript语言精粹/" itemprop="url">
                  JavaScript语言精粹
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T12:12:23+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/JavaScript语言精粹/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/JavaScript语言精粹/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-精华"><a href="#第一章-精华" class="headerlink" title="第一章 精华"></a>第一章 精华</h1><h1 id="第二章-语法"><a href="#第二章-语法" class="headerlink" title="第二章 语法"></a>第二章 语法</h1><h2 id="铁路图"><a href="#铁路图" class="headerlink" title="铁路图"></a>铁路图</h2><p><ul><br>    <li>从左边开始，沿着轨道到右边界</li><br>    <li>圆框中是字面量，方框中是规则或描述</li><br>    <li>任何沿着轨道能走通的序列都是合法的，反之是非法的</li><br>    <li>末端只有一个竖条的铁路图，表示允许在任意一对符号中插入空白。而末端有两个竖条的则不允许。</li><br></ul></p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>指数表示法：字面量值等于e之前的数字与10的e之后数字的次方相乘，即 100 等于1e2.<br>NaN：数值，表示不能产生正常结果的运算结果，不等于任何值NaN!=NaN，通过isNaN(number)检测。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>for in 会枚举对象的所有属性名（或键名），通过hasOwnProperty()检测某属性是该对象的成员，还是来自原型链。</p>
<pre><code>for (myvar in obj){
    if(obj.hasOwnProperty(myvar)){
        ...
    }
}
</code></pre><p>break使程序退出循环或switch语句，如果指定标签则退出带有该标签的程序段（可用于退出嵌套循环，continue同）</p>
<pre><code>hollton : for(var i=0;i&lt;3;i++){
    for(var j=0;j&lt;3;j++){
        if(i===1&amp;&amp;j===1){
            break hollton;
        }else{
            console.log(&quot;i:&quot;+i+&quot;--j:&quot;+j);
        }
    }
}
</code></pre><p>如果没指定标签，break只退出内部循环，指定标签后，则退出标签指定的代码段，即整个循环。</p>
<h1 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对象通过引用传递，永远不会被复制。</p>
<pre><code>var x = {};
var y = x;
y.name = &apos;hah&apos;;
console.log(x.name);  //&apos;hah&apos;,因为x,y指向同一个对象的引用

var a = {},b = {};  //a,b引用一个不同的空对象
var a = b = {};  //a,b引用同一个的空对象
</code></pre><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个对象都连接到一个原型对象，并可从中继承属性。原型连接只在检索值的时候才被用到，获取某个对象的某属性值时，若该对象没此属性名，则js从原型对象中获取，若原型对象中也没有，再从原型链上获取，直到Object.prototype，仍不存在返回undefined。这个过程称为委托。</p>
<h1 id="第四章-函数"><a href="#第四章-函数" class="headerlink" title="第四章 函数"></a>第四章 函数</h1><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。函数接收两个附加的参数：this和arguments。this的取值取决于调用的模式。<br>JavaScript共有4种调用模式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式。</p>
<h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><p>当函数被保存为对象的属性时，称之为方法。当方法被调用时，this被绑定到该对象，通过this可获取到所属对象的上下文的方法称为公共方法。</p>
<h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><p>当函数不是对象的属性时，则作为函数调用，此时this被绑定到全局对象。导致内部函数不能通过this访问外部函数的属性及方法，但可通过在外部函数定义变量（如_this,that）并赋值为this，可使内部函数访问。</p>
<h2 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h2><p>若函数通过new调用，则会创建一个新对象，该新对象连接到该函数的prototype成员，同时this被绑定到该新对象上，即this指向该构造器实例。</p>
<h2 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h2><p>Fn.apply(obj,args)方法接收两个参数：</p>
<p><ol><br>    <li>obj是要绑定给this的值，即obj将代替Fn里的this对象</li><br>    <li>args是要传递给调用函数的参数数组，即args–&gt;arguments</li><br></ol><br>call同apply，只有参数列表不一样 ：Fn.call(obj,arg1,arg2,…)</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>函数被调用时，可以通过arguments访问传递的参数列表，包括多余形参。arguments是类似数组的对象，拥有length属性，但没有任何数组方法。</p>
<h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><p>函数总会返回值，若没指定则返回undefined。若通过new调用函数且返回值不是对象，则会返回this，即该新对象。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数作用域使得内部函数可访问其外部函数的参数和变量（除this和arguments）。</p>
<pre><code>//创建hollton构造函数，构造出带有getName方法和name私有属性的对象
var hollton = function(name){
    return {
        getName:function(){
            return name;
        };
    }
}
var hd = hollton(&apos;holl&apos;);
console.log(hd.getName());
</code></pre><p>当调用hollton时，它返回包含getName方法的新对象，即使hollton已经返回了但getName仍有特权访问hollton对象的name属性，称为闭包。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>可使用函数和闭包构造函数，模块是一个提供接口而隐藏状态及实现的函数或对象。<br>模块的一般形式：定义了私有变量和特权函数的函数。利用闭包创建可以访问私有变量和函数的特权函数，并返回这个特权函数。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化允许把函数与传递来的参数相结合，并产生一个新的函数。</p>
<pre><code>function curry(fn){
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return fn.apply(null, finalArgs);
    };
}
</code></pre><h2 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h2><p>函数可以将先前的结果记录在某个对象里，从而避免无谓的重复计算。</p>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><p>基于类的语言中，对象是类的实例，且类可以从另一个类继承。JavaScript是基于原型的语言，这意味着对象直接从其他对象继承。</p>
<h1 id="第六章-数组"><a href="#第六章-数组" class="headerlink" title="第六章 数组"></a>第六章 数组</h1><h1 id="第七章-正则表达式"><a href="#第七章-正则表达式" class="headerlink" title="第七章 正则表达式"></a>第七章 正则表达式</h1><h1 id="第八章-方法"><a href="#第八章-方法" class="headerlink" title="第八章 方法"></a>第八章 方法</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="array-concat-item…"><a href="#array-concat-item…" class="headerlink" title="array.concat(item…)"></a>array.concat(item…)</h3><p>concat产生新数组，包含原数组的浅复制并附加一个或多个item参数，若参数item是数组则会分别添加参数数组的元素。</p>
<h3 id="array-join-separator"><a href="#array-join-separator" class="headerlink" title="array.join(separator)"></a>array.join(separator)</h3><p>join把数组转为字符串并用separator分隔符连接（默认’,’）。<del>join方法通常比+运算符更快。</del>（IE7+及现代浏览器对+运算符优化，因此连接字符串优先使用+运算）。</p>
<h3 id="array-push-item…"><a href="#array-push-item…" class="headerlink" title="array.push(item…)"></a>array.push(item…)</h3><p>push会修改原数组并在尾部附加一个或多个item，并返回数组的新长度。若参数item是数组则会把参数数组当作元素项添加。</p>
<h3 id="array-pop"><a href="#array-pop" class="headerlink" title="array.pop()"></a>array.pop()</h3><p>pop移出数组最后一个元素并返回该元素，若数组为[]，则返回undefined。</p>
<h3 id="array-unshift-item…"><a href="#array-unshift-item…" class="headerlink" title="array.unshift(item…)"></a>array.unshift(item…)</h3><p>unshift方法同push，但是向首部添加元素。</p>
<h3 id="array-shift"><a href="#array-shift" class="headerlink" title="array.shift()"></a>array.shift()</h3><p>shift方法同pop，但是移出数组第一个元素。</p>
<h3 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array.reverse()"></a>array.reverse()</h3><p>reverse反转数组元素的顺序，并返回该数组。</p>
<h3 id="array-sort-compareFn"><a href="#array-sort-compareFn" class="headerlink" title="array.sort(compareFn)"></a>array.sort(compareFn)</h3><p>sort方法默认是将数组元素转换为string再进行比较排序，但可通过compareFn提供比较方法。</p>
<h3 id="array-slice-start-end"><a href="#array-slice-start-end" class="headerlink" title="array.slice(start,end)"></a>array.slice(start,end)</h3><p>slice对数组做浅复制并返回新数组，从array[start]，复制到array[end]止（不包括array[end]项）。<br>end可选，默认是array.length。<br>若start或end为负数，则会先和array.length相加计算，再进行复制<br>若start大于（end或array.length），则会返回[]。</p>
<h3 id="array-splice-start-deleteCount-item…"><a href="#array-splice-start-deleteCount-item…" class="headerlink" title="array.splice(start,deleteCount,item…)"></a>array.splice(start,deleteCount,item…)</h3><p>splice从array[start]处移出deleteCount个元素，并用item替换。返回被移除元素的数组。</p>
<h1 id="第九章-代码风格"><a href="#第九章-代码风格" class="headerlink" title="第九章 代码风格"></a>第九章 代码风格</h1><h1 id="第十章-优美的特性"><a href="#第十章-优美的特性" class="headerlink" title="第十章 优美的特性"></a>第十章 优美的特性</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/03/05/滴答，滴答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/滴答，滴答/" itemprop="url">
                  滴答，滴答
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-05T21:28:30+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/滴答，滴答/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/滴答，滴答/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>夜晚，正俯身在电脑前写着设计模式笔记，窗前忽然哗啦啦下起了小雨，莫名就吟出两句小学课本的内容：“下吧下吧，我要种瓜”，回想往事一切仿佛历历在目，却再也回不去。</p>
<blockquote>
<p>滴答，滴答<br>滴答，滴答，下雨啦，下雨啦。<br>麦苗说：“下吧，下吧，我要长大。”<br>桃树说：“下吧，下吧，我要开花。”<br>葵花子说：“下吧，下吧，我要发芽。”<br>小弟弟说：“下吧，下吧，我要种瓜。”<br>滴答，滴答，下雨啦，下雨啦。 </p>
</blockquote>
<p>　</p>
<blockquote>
<p>春天来了<br>春天对冰雪说了什么，<br>冰雪那么听话，都化了。<br>春天对小草说了什么，<br>小草那么听话，都绿了。<br>春天对花儿说了什么，<br>花儿那么听话，都开了。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://hollton.github.io/2017/02/25/javascript设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hollton">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/css/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HOLLTON">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/25/javascript设计模式/" itemprop="url">
                  JavaScript设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-25T16:05:40+08:00">
                2017-02-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/25/javascript设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/25/javascript设计模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-富有表现力的javascript"><a href="#第一章-富有表现力的javascript" class="headerlink" title="第一章 富有表现力的javascript"></a>第一章 富有表现力的javascript</h1><h2 id="javascript的灵活性"><a href="#javascript的灵活性" class="headerlink" title="javascript的灵活性"></a>javascript的灵活性</h2><h3 id="过程式程序设计模式"><a href="#过程式程序设计模式" class="headerlink" title="过程式程序设计模式"></a>过程式程序设计模式</h3><pre><code>function startRun(){ ... };
function stopRun(){ ... };
</code></pre><p>特点：简单，但无法创建可以保存状态且具有仅对其内部状态进行操作的方法的对象。</p>
<h3 id="定义类，并把方法赋给该类的prototype属性"><a href="#定义类，并把方法赋给该类的prototype属性" class="headerlink" title="定义类，并把方法赋给该类的prototype属性"></a>定义类，并把方法赋给该类的prototype属性</h3><pre><code>var Run = function(){ ... };
Run.prototype = {
    start:function(){ ... },
    stop:function(){ ... }
};
/* usage */
var myRun = new Run();
myRun.start();
</code></pre><h3 id="自定义为类添加新方法"><a href="#自定义为类添加新方法" class="headerlink" title="自定义为类添加新方法"></a>自定义为类添加新方法</h3><pre><code>/* 给函数添加可自定义方法的方法 */
Function.prototype.customMethod = function(name,fn){
    this.prototype[name] = fn;
    //以下代码可使customMethod被链式调用
    //return this;
};
var Run = function(){ ... }
Run.customMethod(&apos;start&apos;,fuction(){
    ...
});
</code></pre><h2 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h2><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>布尔（Boolean），数值（Number不区分整数、浮点数），字符串（String），空（Null），未定义（Undefined）：按值传送</p>
<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>对象（Object：无序键值对；数组特殊对象：为有序集合）：按引用传送</p>
<h1 id="第二章-接口"><a href="#第二章-接口" class="headerlink" title="第二章 接口"></a>第二章 接口</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>接口提供了一种用以说明一个对象应该具有哪些方法的手段。我的理解是接口声明了一个方法所需的参数及返回的数据，并在类中去实现它。</p>
<h2 id="js模仿接口"><a href="#js模仿接口" class="headerlink" title="js模仿接口"></a>js模仿接口</h2><h3 id="注释描述"><a href="#注释描述" class="headerlink" title="注释描述"></a>注释描述</h3><p>在注释中使用interface,implements关键字。实现简单但仅限制于文档规范阶段，并没做实现检查，也不会抛出错误提示。</p>
<pre><code>/*
    interface Composite {
        function add(item);
    }
*/
var CompositeForm = function(id,method,action){  //implements Composite
};
//implement the Composite interface
CompositeForm.prototype.add = function(item){ ... }
</code></pre><h3 id="属性检查"><a href="#属性检查" class="headerlink" title="属性检查"></a>属性检查</h3><p>即通过检查属性判断是否实现此接口，没有则抛出错误，但并未对接口的真正实现做检查。</p>
<h3 id="鸭式辨型"><a href="#鸭式辨型" class="headerlink" title="鸭式辨型"></a>鸭式辨型</h3><p>不关注是否声明支持哪些方法，而只要具有这些接口的方法就行。双重遍历检测每个接口是否实现了某种方法.</p>
<h2 id="interface类"><a href="#interface类" class="headerlink" title="interface类"></a>interface类</h2><p>接口在运用设计模式实现复杂系统时能体现其价值，可降低对象间的耦合度，但对于小型项目，好处并不明显且徒增复杂度。</p>
<h1 id="第三章-封装和信息隐藏"><a href="#第三章-封装和信息隐藏" class="headerlink" title="第三章 封装和信息隐藏"></a>第三章 封装和信息隐藏</h1><h2 id="封装是面向对象设计的基石"><a href="#封装是面向对象设计的基石" class="headerlink" title="封装是面向对象设计的基石"></a>封装是面向对象设计的基石</h2><p>将方法或属性声明为私用，可以让对象的实现细节对其他对象保密以降低对象间耦合度，且可以保持数据的完整性并对其修改方式加以约束。js中可使用闭包创建只允许从对象内部访问的属性和方法，以达到封装数据的效果。</p>
<h2 id="创建对象的基本模式"><a href="#创建对象的基本模式" class="headerlink" title="创建对象的基本模式"></a>创建对象的基本模式</h2><h3 id="门户大开型"><a href="#门户大开型" class="headerlink" title="门户大开型"></a>门户大开型</h3><p>传统方式，用函数做其构造器，属性和方法公开，用this关键字创建属性。</p>
<pre><code>var book = function(title){
    this.setTitle(title);
};
book.prototype = {
    getTitle:function(){
        return this.title;
    },
    setTitle:function(title){
        this.title = title;
    },
    display:function(){ ... }
};
</code></pre><h3 id="命名规范（-）"><a href="#命名规范（-）" class="headerlink" title="命名规范（_）"></a>命名规范（_）</h3><p>属性和方法前添加下划线（_）以示其私有性。</p>
<h3 id="作用域、嵌套函数、闭包"><a href="#作用域、嵌套函数、闭包" class="headerlink" title="作用域、嵌套函数、闭包"></a>作用域、嵌套函数、闭包</h3><p>闭包函数能够访问另一个函数的内部变量，函数作用域内return一个嵌套函数即构成闭包。<br>之所以会产生闭包是因为js的作用域是词法性的，即函数运行在定义它们的作用域中，而不是调用它们的作用域。</p>
<pre><code>var book = function(newTitle){
    //私有属性
    var title;
    //特权方法（privileged method，公用却能访问私有属性）
    this.getTitle = function(){
        return title;
    };
    this.setTitle = function(newTitle){
        title = newTitle;
    };
    //构造函数代码
    this.setTitle(newTitle);
};
//公用方法
book.prototype.display = function(){ ... };
</code></pre><p>前两种方式的方法都创建在原型对象中，无论生成多少对象实例，方法只在内存中存一份。而采用闭包则每生成一个对象实例都为每一个私有方法和特权方法生成新副本，更耗内存。</p>
<h1 id="第四章-继承"><a href="#第四章-继承" class="headerlink" title="第四章 继承"></a>第四章 继承</h1><h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><h3 id="简单类声明"><a href="#简单类声明" class="headerlink" title="简单类声明"></a>简单类声明</h3><p>函数声明类，new关键字创建实例。创建构造函数，其名称就是类名，首字母大写，实例属性使用this关键字，方法添加到其prototype对象中。</p>
<pre><code>/* Class Person */
function Person (name){
    this.name = name;
};
Person.prototype.getName = function(){
    return this.name;
};
</code></pre><p>关键字new调用构造函数创建该类实例，即可访问实例属性及方法。</p>
<pre><code>var hollton = new Person(&apos;hollton&apos;);
</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ol><br>    <li>创建一个构造函数，在函数中调用超类的构造函数。<ul><li>使用new时，系统会创建一个空对象，然后调用构造函数，在此过程中这个空对象处于作用域链最前端。而子类调用超类的构造函数时，必须手动完成这项工作。“Person.call(this,name)”使空对象（用this代表），name作参数传入。</li></ul></li><br>    <li>设置原型链，指向实例超类<ul><li>访问对象的某个成员时，如果在当前对象中查找不到，javascript会沿着对象的原型链向上逐一访问其原型对象查找，因此将子类的prototype指向超类的一个实例，即可使子类继承超类。</li></ul></li><br>    <li>重新设置constructor属性为本构造函数<ul><li>定义构造函数时，默认的prototype对象是Object类型的实例，其constructor属性会被自动设置为该构造函数。但手动将其prototype设置为另一个对象时，其constructor属也变成新对象的constructor值，因此需要重新设置为本构造函数。</li></ul></li><br></ol>

<pre><code>/* Class Programmer */
function Programmer(name,programs){
    Person.call(this,name);//当前作用域调用超类的构造函数
    this.programs = programs;//添加新属性
};
Programmer.prototype = new Person();//设置原型链
Programmer.prototype.constructor = Programmer;//重新设置constructor属性
Programmer.prototype.getPrograms = function(){//添加新方法
    return this.programs;
};
</code></pre><p>创建子类实例则不变</p>
<pre><code>var holltonliu = new Programmer(&apos;hollton&apos;,[&apos;javascript_code&apos;]);
</code></pre><h3 id="自定义extend函数"><a href="#自定义extend函数" class="headerlink" title="自定义extend函数"></a>自定义extend函数</h3><p>仿照extend关键字自定义函数实现基于给定类结构创建新类。其中添加一个空函数fn，其prototype指向超类的prototype并创建对象实例插入到子类的原型链中。这样是为了避免创建超类的实例（直接使用超类可能：比较大；有副作用；执行大量计算任务）。</p>
<pre><code>/* Extend function */
function extend(subClass, superClass) {
    var fn = function(){};
    fn.prototype = superClass.prototype;
    subClass.prototype = new fn();
    subClass.prototype.constructor = subClass;
}
</code></pre><p>使用extend函数对上述例子改造：</p>
<pre><code>function Programmer(name,programs){
    Person.call(this,name);  //存在耦合
    this.programs = programs;
};
extend(Programmer,Person);
Programmer.prototype.getPrograms = function(){
    return this.programs;
};
</code></pre><p>存在缺陷：超类（Person）被固化在子类（Programmer）的声明中，为子类添加superPrototype属性解决↓</p>
<pre><code>/* ---Improved Extend function--- */
function extend(subClass, superClass) {
    var fn = function(){};
    fn.prototype = superClass.prototype;
    subClass.prototype = new fn();
    subClass.prototype.constructor = subClass;

    subClass.superPrototype = superClass.prototype;
    //超类为Object类或也由他处继承而来时，有可能导致constructor指向不正确，不正确时修复。
    //子类会通过constructor指向调用超类构造函数，因此这个判断修复很重要！
    if(superClass.prototype.constructor == Object.prototype.constructor){
        superClass.prototype.constructor = superClass;
    }
}
function Programmer(name,programs){
    Person.superPrototype.constructor.call(this,name);
    this.programs = programs;
};
extend(Programmer,Person);
</code></pre><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>创建一个对象，由于原型链的查找机制，新对象只需重用此对象即可实现继承。</p>
<pre><code>/* Person Prototype Object */
var Person = {
    name:&apos;default&apos;,
    getName:function(){
        return this.name;
    }
};
//customClone创建并返回新空对象，其原型对象指向父级对象
//当新对象找不到某个属性或方法时会在原型链上查找
function customClone(superObject) {
    function fn() {};
    fn.prototype = superObject;
    return new fn;  //相当于new fn()
}
/* Programmer Prototype Object */
var Programmer = customClone(Person);
Programmer.programs = [];
Programmer.getPrograms = function(){
    return this.programs;
};
var hollton = customClone(Programmer);
hollton.name = &apos;hollton&apos;;
hollton.programs = [&apos;javascript_code&apos;];
hollton.getName();
hollton.getPrograms();
</code></pre><h3 id="继承成员的读写不对等性"><a href="#继承成员的读写不对等性" class="headerlink" title="继承成员的读写不对等性"></a>继承成员的读写不对等性</h3><p>在类式继承中，每个实例都有一份自己的副本，而通过原型继承，实例只是以父对象为原型对象的空对象，没为其指定属性时，读取是返指原型链上的同名属性，写入则为其定义一个新属性。这里特别要注意的是，对于引用传递的数据类型如数组，对新对象第一次不赋值写入而做操作如push时会修改其原型链上的数据。</p>
<pre><code>var hd = customClone(Programmer);
console.log(Programmer.programs);  //[]
//不应这么做
hd.programs.push(&apos;javascript_code&apos;);
console.log(Programmer.programs);  //[&apos;javascript_code&apos;]
//应该
hd.programs = [];  //为hd对象添加新属性
hd.programs.push(&apos;javascript_code&apos;);
console.log(Programmer.programs);  //[]
</code></pre><h3 id="工厂方式实现"><a href="#工厂方式实现" class="headerlink" title="工厂方式实现"></a>工厂方式实现</h3><p>如果需求继承一个对象而只修改其子对象的的一个属性保留其他，应用上种方法你必须知道对象的全部属性及其默认值并做覆盖操作，显然不合适。</p>
<pre><code>var CompoundObject = {};
CompoundObject.name = &apos;haha&apos;;
CompoundObject.createChildObject = function(){
    return {
        num:10,
        bool:true
    }
};
CompoundObject.childObject = CompoundObject.createChildObject();

var compoundObjectClone = customClone(CompoundObject);
compoundObjectClone.childObject = CompoundObject.createChildObject();
compoundObjectClone.childObject.num = 5;  //修改不会影响CompoundObject
</code></pre><h2 id="参元类"><a href="#参元类" class="headerlink" title="参元类"></a>参元类</h2><p>包含通用方法的类，用来扩充其他类，称这个通用类为参元类(mixin class)。它们通常不会被实例或直接调用，只是向其他类提供自己的方法。</p>
<pre><code>/* Mixin class */
var Mixin = function(){};
Mixin.prototype = {
    fnName:function(){ ... }
}
</code></pre><p>这个方法在不同类中用到时，没必要都去继承它，我们可以自定义个customArgument函数将它添加到需要用到它的类中。</p>
<pre><code>function customArgument(receiveClass, giveClass){
    for(methodName in giveClass.prototype){
        if(!receiveClass.prototype[methodName]){
            receiveClass.prototype[methodName] = giveClass.prototype[methodName];
        }
    }
}

customArgument(Programmer,Mixin);
var hd. = new Programmer(&apos;hollton&apos;,[&apos;javascript_code&apos;]);
hd.fnName();  //使用参元类方法
</code></pre><h1 id="第五章-单体模式"><a href="#第五章-单体模式" class="headerlink" title="第五章 单体模式"></a>第五章 单体模式</h1><p>单体是一个用来划分命名空间并将一批相关方法和属性组织在一起的对象，如果可被实例化，则只能被实例化一次。</p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><pre><code>/* 简单单体（对象字面量） */
var Singleton = {
    attribute:10,
    method:function(){}
};
</code></pre><h2 id="拥有私有成员的单体"><a href="#拥有私有成员的单体" class="headerlink" title="拥有私有成员的单体"></a>拥有私有成员的单体</h2><p>创建类的私有成员的做法缺点在于较耗内存，因为每个实例都具有方法的一份新副本。由于单体对象只会被实例化一次，因此为其定义私用方法是不必考虑内存方面的问题。</p>
<h3 id="下划线标识"><a href="#下划线标识" class="headerlink" title="下划线标识"></a>下划线标识</h3><h3 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h3><pre><code>MyNamespace.Singleton = (function(){
    //私有
    var privateAtti = false;
    function privateMethod = function(){};
    //公有
    return {
        publicAtti = true;
        publicMethod = function(){};
    };
})();
</code></pre><p>这种单体模式又称模块模式，它可以把一批相关的方法和属性组织为模块并起到划分命名空间的作用。</p>
<h2 id="惰性实例化"><a href="#惰性实例化" class="headerlink" title="惰性实例化"></a>惰性实例化</h2><p>将单体对象实例化推迟到需要使用的时候，称为惰性加载。特别之处是需借助静态方法调用MyNamespace.Singleton.publicMethod -&gt; MyNamespace.Singleton.getInstace().publicMethod。getInstace方法会检查并返回该单体的实例化对象。</p>
<pre><code>MyNamespace.Singleton = (function(){
    function constructor(){
        var privateAtti = false;
        function privateMethod = function(){};
        return {
            publicAtti = true;
            publicMethod = function(){};
        };
    }
    var uniqueInstance;
    return {
        getInstance:function(){
            if(!uniqueInstance){
                uniqueInstance = constructor();
            }
            return uniqueInstance;
        }
    }
})();
</code></pre><h1 id="第六章-方法的链式调用"><a href="#第六章-方法的链式调用" class="headerlink" title="第六章 方法的链式调用"></a>第六章 方法的链式调用</h1><p>类的每个方法都return this实现支持方法链式调用的类。</p>
<h1 id="第七章-工厂模式"><a href="#第七章-工厂模式" class="headerlink" title="第七章 工厂模式"></a>第七章 工厂模式</h1><p>简单工厂使用一个类（通常是一个单体）来生成实例，标准工厂使用子类来决定一个成员变量应该是哪个具体类的实例。</p>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>简单工厂就像一个单例，它有一个或多个方法来创建或者返回对象。</p>
<pre><code>/* BicycleShop Class */
var BicycleShop = function(){};
BicycleShop.prototype = {
    sellBicycle:function(model){
        var bicycle;
        switch (model){
            case &apos;speedster&apos;:
                bicycle = new Speedster();
                break;
            case &apos;lowrider&apos;:
                bicycle = new Lowrider();
                break;
            default:
                bicycle = new Common();
        }
        return bicycle;
    }
}

/* Speedster Class */
var Speedster = function(){};
Speedster.prototype = {
    assemble:function(){},
    ride:function(){}
}
var newBicycleShop = new BicycleShop();
var newBike = newBicycleShop.sellBicycle(&apos;speedster&apos;);
</code></pre><p>当添加一种车型时，不得不BicycleShop代码，更好的方式是在子类中创建车型。</p>
<h2 id="标准工厂"><a href="#标准工厂" class="headerlink" title="标准工厂"></a>标准工厂</h2><p>工厂是一个将其成员对象的实例化推迟到子类中进行的类。把BicycleShop设计成抽象类，只实现通用方法，让子类各自实现个性如createBicycle方法。</p>
<pre><code>/* BicycleShop Class (abstract) */
var BicycleShop = function(){};
BicycleShop.prototype = {
    sellBicycle:function(model){
        var bicycle = this.createBicycle(model);
        return bicycle;
    },
    createBicycle:function(model){
        throw new Error(&apos;createBicycle须由子类实现&apos;);
    };
}

/* SubBicycleShop Class */
var SubBicycleShop = function(){};
SubBicycleShop.prototype = new BicycleShop();
SubBicycleShop.prototype.createBicycle = function(model){
        var bicycle;
        switch (model){
            case &apos;speedster&apos;:
                bicycle = new SubSpeedster();
                break;
            case &apos;lowrider&apos;:
                bicycle = new SubLowrider();
                break;
            default:
                bicycle = new SubCommon();
        }
        return bicycle;
    };
}
</code></pre><h2 id="memoizing技术"><a href="#memoizing技术" class="headerlink" title="memoizing技术"></a>memoizing技术</h2><p>memoizing把函数的每次执行结果都存入键值对(数组)，下次直接在键值对中查找值，有则返回该值，没有则执行函数体并再次缓存。</p>
<h1 id="第八章-桥接模式"><a href="#第八章-桥接模式" class="headerlink" title="第八章 桥接模式"></a>第八章 桥接模式</h1><p>桥接模式最常见和实际的应用场合之一是事件监听器回调函数。</p>
<h2 id="示例：事件监听器"><a href="#示例：事件监听器" class="headerlink" title="示例：事件监听器"></a>示例：事件监听器</h2><pre><code>addEvent(ele,&apos;click&apos;,getBeerById);
function getBeerById (e){
    asyncRequest(&apos;GET&apos;,&apos;/getBeer?id=&apos;+this.id,function(resp){
        console.log(resp);
    });
}
</code></pre><p>作为一个API函数，不应与特定实现混在一起。用桥接模式修改，把抽象隔离开来。</p>
<pre><code>function getBeerById (id,callBack){
    asyncRequest(&apos;GET&apos;,&apos;/getBeer?id=&apos;+id,function(resp){
        callBack(resp);
    });
}
addEvent(ele,&apos;click&apos;,getBeerByIdBridge);
function getBeerByIdBridge (e){
    getBeerById(this.id,function(beer){
        console.log(beer);
    });
}
</code></pre><p>如果一个桥接函数被用于连接两个函数，而其中某个函数根本不会在桥接函数外被调用，那么这个桥接函数就是不必要的。</p>
<h1 id="第九章-组合模式"><a href="#第九章-组合模式" class="headerlink" title="第九章 组合模式"></a>第九章 组合模式</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/css/images/avatar.png"
               alt="hollton" />
          <p class="site-author-name" itemprop="name">hollton</p>
           
              <p class="site-description motion-element" itemprop="description">前端开发一枚</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hollton</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hollton"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
